/*
President's Cup Cybersecurity Competition 2019 Challenges

Copyright 2020 Carnegie Mellon University.

NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR
IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF
FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS
OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT,
TRADEMARK, OR COPYRIGHT INFRINGEMENT.

Released under a MIT (SEI)-style license, please see license.txt or
contact permission@sei.cmu.edu for full terms.

[DISTRIBUTION STATEMENT A] This material has been approved for public
release and unlimited distribution.  Please see Copyright notice for
non-US Government use and distribution.

DM20-0347
*/

extern crate crypto;
extern crate libloading;
extern crate winapi;

use crypto::buffer::{BufferResult, ReadBuffer, WriteBuffer};
use crypto::{aes, blockmodes, buffer, symmetriccipher};
use std::io;
use std::mem::size_of;
use std::time::{Duration, SystemTime};
use winapi::shared::minwindef::{DWORD, PDWORD, PULONG, ULONG};
use winapi::shared::ntdef::{NTSTATUS, NULL};
use winapi::um::debugapi;
use winapi::um::processthreadsapi;
use winapi::um::winnt::HANDLE;

static mut START_TIME: SystemTime = SystemTime::UNIX_EPOCH;

const PROCESS_DEBUG_PORT: u32 = 7;
#[cfg(feature = "version_1")]
const ENCRYPTION_KEY: [u8; 32] = [
    0x52, 0xa3, 0x27, 0xc1, 0x34, 0xdf, 0xe7, 0x98, 0x68, 0x7c, 0x42, 0x7b, 0xdf, 0x83, 0xd6, 0x78,
    0xc1, 0xb0, 0x8d, 0xdc, 0xd1, 0x59, 0x6e, 0x3b, 0x92, 0xd, 0xd9, 0xc0, 0x48, 0x56, 0x20, 0xb2,
];
#[cfg(feature = "version_1")]
const ENCRYPTION_IV: [u8; 16] = [
    0xa, 0xdd, 0xa3, 0x3, 0xc9, 0x9c, 0xa4, 0xbf, 0x36, 0x72, 0x46, 0x31, 0xaf, 0x3e, 0xc2, 0xa5,
];
#[cfg(feature = "version_1")]
const CIPHER_TEXT_HEX: [u8; 160] = [
    0x28, 0xbb, 0xe3, 0x69, 0xc4, 0x64, 0xeb, 0xf6, 0xf1, 0x70, 0xa5, 0x3, 0xc6, 0x17, 0x30, 0xde,
    0x4a, 0x45, 0x2, 0x2d, 0xe8, 0xa1, 0x13, 0x69, 0x8e, 0x4b, 0x3, 0x77, 0x8f, 0xe, 0x3b, 0x61,
    0xbe, 0x16, 0xa2, 0xd6, 0x30, 0xd4, 0x55, 0x88, 0xf, 0x7c, 0x54, 0xa2, 0xed, 0xdd, 0xca, 0x8b,
    0x6a, 0x38, 0xdb, 0xcc, 0xbe, 0xe5, 0xd9, 0xb3, 0x90, 0xc8, 0xca, 0x73, 0x7d, 0x33, 0xd, 0xf5,
    0xdc, 0xb, 0x2d, 0x1f, 0x84, 0xa, 0x96, 0x5, 0xa1, 0xb8, 0x79, 0x56, 0xb1, 0xc5, 0x4b, 0x1e,
    0xe2, 0x27, 0x1a, 0xec, 0x65, 0x1c, 0x8c, 0x22, 0xd8, 0x91, 0x3c, 0x57, 0xc3, 0xfc, 0x51, 0x6d,
    0x6, 0xad, 0xdb, 0x98, 0x4b, 0x72, 0x91, 0x57, 0xf, 0xd5, 0xb4, 0x98, 0x7b, 0x43, 0xc5, 0x63,
    0xd9, 0xfa, 0x38, 0x4, 0xf6, 0xfa, 0x4, 0xe0, 0xe3, 0x16, 0xd5, 0x2, 0xc8, 0x64, 0xdf, 0x13,
    0x75, 0xb9, 0xe8, 0x58, 0xda, 0x76, 0x20, 0xf1, 0x21, 0x18, 0xa5, 0xbb, 0x4a, 0xd, 0x9f, 0x61,
    0xfb, 0x81, 0x94, 0xd4, 0xa5, 0x1a, 0x81, 0xe, 0x90, 0x8c, 0xbe, 0xb, 0x18, 0x48, 0xad, 0x2f,
];
#[cfg(feature = "version_2")]
const ENCRYPTION_KEY: [u8; 32] = [
    0xe9, 0x76, 0x64, 0x4c, 0xa9, 0x2, 0xba, 0xc8, 0x7f, 0x96, 0x6f, 0x21, 0xa6, 0xaf, 0x1f, 0x7e,
    0x65, 0xe0, 0xbc, 0xd9, 0xa7, 0x75, 0x83, 0xbf, 0x9b, 0x86, 0xca, 0x24, 0xf, 0xac, 0xc1, 0x4,
];
#[cfg(feature = "version_2")]
const ENCRYPTION_IV: [u8; 16] = [
    0x84, 0xdd, 0x5a, 0xc4, 0x81, 0x13, 0xb5, 0x85, 0xc3, 0x60, 0x77, 0x43, 0xe0, 0xa2, 0x5a, 0xa,
];
#[cfg(feature = "version_2")]
const CIPHER_TEXT_HEX: [u8; 160] = [
    0x36, 0x4c, 0xe0, 0x44, 0xa8, 0xcf, 0xaf, 0x7d, 0xc4, 0x4f, 0xd0, 0xc2, 0xa7, 0xb6, 0x6e, 0xc0,
    0x20, 0x24, 0x50, 0x9d, 0xb7, 0x6, 0x6, 0x86, 0x32, 0x73, 0x77, 0x57, 0x94, 0xed, 0x87, 0x18,
    0x2d, 0x1a, 0x97, 0x66, 0x4f, 0x12, 0x17, 0xb6, 0x78, 0x85, 0x92, 0xef, 0x4b, 0xe8, 0x5d, 0x8,
    0xa2, 0xa2, 0x4b, 0xa1, 0xa8, 0xde, 0x87, 0xfd, 0x30, 0xb, 0x4b, 0xd8, 0x8e, 0x97, 0xf6, 0xf1,
    0x9a, 0xd3, 0xc3, 0x31, 0xef, 0x65, 0xe6, 0x35, 0x3c, 0x2d, 0xc4, 0xfb, 0x97, 0x16, 0x85, 0x23,
    0x5, 0xad, 0xa, 0x3b, 0xbc, 0x4d, 0x56, 0xd0, 0xa, 0x45, 0x24, 0xa, 0xde, 0x25, 0xf6, 0xcf,
    0x54, 0xb, 0x43, 0xc6, 0x25, 0xb7, 0xe1, 0xef, 0x3d, 0xc4, 0x68, 0x18, 0xa, 0x56, 0x2f, 0x14,
    0xa1, 0xb9, 0xb4, 0xa1, 0xd7, 0x4a, 0x6e, 0xc8, 0xa5, 0x33, 0x12, 0x9e, 0x94, 0x7d, 0x3e, 0xd9,
    0xd0, 0xd7, 0x69, 0xec, 0xb9, 0x86, 0x8f, 0x34, 0x71, 0x20, 0xb7, 0x25, 0x8, 0xc4, 0x94, 0xdd,
    0xc5, 0x42, 0x3, 0x63, 0x68, 0xd5, 0xa, 0xe0, 0xf7, 0x55, 0x70, 0x3c, 0x47, 0x4e, 0xee, 0x40,
];
#[cfg(feature = "version_3")]
const ENCRYPTION_KEY: [u8; 32] = [
    0x0, 0x87, 0xbf, 0x0, 0xda, 0x22, 0xcd, 0xa4, 0xed, 0xa6, 0x5c, 0xbf, 0xaa, 0xea, 0x52, 0x2b,
    0xa5, 0x7f, 0x52, 0xab, 0x76, 0x17, 0xfa, 0x41, 0x93, 0xa3, 0x99, 0x3b, 0x81, 0xc3, 0x2d, 0x2d,
];
#[cfg(feature = "version_3")]
const ENCRYPTION_IV: [u8; 16] = [
    0x17, 0x6e, 0x20, 0x17, 0x55, 0x3b, 0xb7, 0x47, 0xb6, 0xc, 0x59, 0x72, 0x35, 0x20, 0x20, 0x40,
];
#[cfg(feature = "version_3")]
const CIPHER_TEXT_HEX: [u8; 160] = [
    0xcd, 0x9b, 0xc9, 0x56, 0x78, 0x21, 0xd1, 0xc5, 0xab, 0x88, 0x6b, 0xa8, 0x6f, 0x64, 0x80, 0xef,
    0xf9, 0xcb, 0x79, 0xdf, 0xab, 0xd0, 0x19, 0xf7, 0x68, 0xf8, 0xfc, 0x43, 0x3b, 0x5, 0x9d, 0xd4,
    0xd0, 0xd6, 0xd8, 0x13, 0xe9, 0xab, 0x8f, 0xf4, 0xa3, 0x70, 0xda, 0xb0, 0xc, 0x78, 0xae, 0x27,
    0xe1, 0x25, 0x5a, 0x78, 0x2f, 0xcd, 0x52, 0x53, 0x12, 0xbf, 0x15, 0xa6, 0x0, 0xac, 0x3a, 0xd3,
    0xf5, 0x71, 0xa6, 0x28, 0xf9, 0x35, 0x98, 0xab, 0xce, 0xce, 0x8d, 0x2f, 0xb9, 0x51, 0x12, 0x5a,
    0x87, 0xab, 0x6, 0x98, 0x8d, 0x6f, 0x29, 0xed, 0x72, 0xe, 0xf6, 0x16, 0xc, 0x65, 0x84, 0xb1,
    0x97, 0x89, 0x26, 0xf9, 0x37, 0xc9, 0x8a, 0x36, 0x26, 0xde, 0xec, 0xe5, 0xa5, 0xa2, 0xe2, 0x71,
    0x3a, 0x8a, 0x56, 0xc4, 0xa5, 0x22, 0xa6, 0x2c, 0xe9, 0x2b, 0x93, 0xd0, 0x1d, 0xa2, 0x68, 0xeb,
    0x1e, 0x4e, 0xf5, 0x92, 0x3d, 0x96, 0x7a, 0xa7, 0x89, 0x64, 0xfe, 0x22, 0xe8, 0x94, 0xcc, 0x2f,
    0x31, 0xf8, 0x32, 0xfa, 0xb0, 0xaa, 0xc3, 0xf8, 0x1c, 0x7c, 0x7b, 0xcd, 0x6a, 0x1, 0xd9, 0xbb,
];

const RED_HERRING_KEY: [u8; 32] = [
    0xb8, 0x7, 0xa7, 0x38, 0x1e, 0x5, 0x31, 0x32, 0x34, 0xfa, 0x2d, 0xa7, 0x83, 0xef, 0x93, 0x35,
    0xc3, 0xec, 0xdf, 0x8f, 0xe7, 0xce, 0xd3, 0xe, 0x5d, 0x9f, 0x93, 0x7e, 0xd5, 0x73, 0xa9, 0xa6,
];
const RED_HERRING_IV: [u8; 16] = [
    0x83, 0xbc, 0x41, 0x27, 0x5d, 0x1e, 0xfc, 0x8c, 0xde, 0x7b, 0xc1, 0xa6, 0xef, 0x4d, 0xa3, 0x9b,
];
const RED_HERRING_CIPHER_TEXT: [u8; 400] = [
    0xc5, 0xd, 0xf7, 0x12, 0x4a, 0xdc, 0xcd, 0x1a, 0xde, 0x8e, 0x54, 0x1d, 0xc9, 0x6c, 0xaf, 0x54,
    0x1b, 0xa0, 0xcb, 0x78, 0xed, 0x6a, 0x41, 0x59, 0x25, 0xec, 0xba, 0x51, 0xa4, 0xe3, 0x41, 0x2,
    0x23, 0x4d, 0xf9, 0x4a, 0x75, 0x2b, 0x13, 0x8b, 0xb7, 0xc7, 0xf6, 0xcb, 0xf7, 0x7, 0x13, 0x78,
    0x22, 0x83, 0x4f, 0xf, 0x24, 0x83, 0xe2, 0xb4, 0xcc, 0x25, 0xf3, 0xc5, 0x13, 0xe7, 0x8d, 0xb5,
    0xb6, 0x11, 0x46, 0x7, 0xf7, 0x93, 0x21, 0x75, 0xd7, 0x52, 0xf9, 0x6f, 0x8f, 0x70, 0xb6, 0xc1,
    0x20, 0x5a, 0x3a, 0x77, 0x5b, 0x99, 0x6, 0xe4, 0x7c, 0xfa, 0xd8, 0x5a, 0x49, 0x7, 0x49, 0x3b,
    0x6c, 0x34, 0x30, 0xf3, 0x45, 0x88, 0x3a, 0x7f, 0xd2, 0x30, 0x2b, 0x3e, 0xf4, 0x66, 0x38, 0x4f,
    0xfc, 0xa3, 0x9d, 0xd0, 0x56, 0x85, 0xe6, 0x46, 0xcb, 0x9e, 0xff, 0x39, 0x51, 0xf9, 0x7a, 0xbc,
    0xc7, 0x7d, 0x2e, 0x88, 0xfb, 0x89, 0xdd, 0xd6, 0x79, 0xf3, 0xf9, 0xb2, 0xde, 0xf7, 0x60, 0x1,
    0x84, 0xfe, 0xe2, 0x7c, 0x72, 0xe, 0x3c, 0xb6, 0x6, 0xa6, 0x89, 0xc1, 0x98, 0x1b, 0xa2, 0xce,
    0x76, 0xe1, 0x3c, 0xa4, 0x95, 0xcc, 0x19, 0x6f, 0x33, 0x4, 0xd1, 0x73, 0xca, 0xf0, 0xff, 0xae,
    0x2b, 0x63, 0xa2, 0x43, 0x34, 0xb9, 0xa6, 0x73, 0x73, 0xd4, 0x2d, 0xf8, 0x99, 0x4e, 0x1, 0x19,
    0x83, 0xdd, 0xec, 0x3f, 0x60, 0x1, 0x75, 0xf1, 0x7b, 0xa, 0xeb, 0xaf, 0x45, 0xf3, 0x33, 0x8a,
    0xf, 0xd2, 0x5a, 0x38, 0x54, 0x4a, 0x3d, 0x63, 0xf4, 0x95, 0x99, 0xe, 0xe1, 0x6d, 0x3c, 0x84,
    0xec, 0x0, 0xa9, 0x54, 0x4c, 0x10, 0xe3, 0x6d, 0xa7, 0xd1, 0x92, 0xb0, 0x20, 0xde, 0x10, 0x95,
    0x35, 0xf6, 0x77, 0xd5, 0x61, 0x5a, 0x5e, 0x5b, 0x4e, 0x1f, 0xe6, 0x81, 0x2b, 0x2, 0xaa, 0xae,
    0x71, 0x27, 0x8, 0x8, 0x50, 0x71, 0xa1, 0x4b, 0xf0, 0xf7, 0x19, 0xe2, 0x47, 0x73, 0xfb, 0x30,
    0x21, 0x7, 0xe6, 0xdf, 0x78, 0x73, 0x37, 0x32, 0x1f, 0xc9, 0xab, 0x6d, 0x43, 0xaf, 0xe9, 0xd2,
    0x3b, 0xe7, 0x48, 0x9a, 0x67, 0xf7, 0xf8, 0x21, 0xe8, 0x40, 0xf0, 0x1e, 0x5b, 0xb8, 0x4c, 0x81,
    0xdf, 0xe9, 0x67, 0x95, 0x74, 0xc8, 0xe1, 0xd, 0xc6, 0x95, 0x6a, 0xb6, 0xdc, 0x28, 0x4, 0xba,
    0xcc, 0x56, 0xb7, 0x42, 0xd5, 0xc0, 0x15, 0x7d, 0x8, 0x37, 0x54, 0x51, 0x35, 0xa4, 0x19, 0x7a,
    0x7d, 0xcb, 0x17, 0x2e, 0xb3, 0x2c, 0x39, 0x45, 0x78, 0xf4, 0x2f, 0xa6, 0x80, 0xfd, 0x6e, 0xcd,
    0xe9, 0xce, 0x9e, 0x40, 0x4a, 0x98, 0x8c, 0x72, 0x70, 0x63, 0xbc, 0xf9, 0xd5, 0x2a, 0xcf, 0x5a,
    0x7f, 0x80, 0x98, 0xbc, 0x28, 0x2b, 0x56, 0x1c, 0x66, 0x20, 0x8b, 0x6f, 0x96, 0x7b, 0x61, 0x84,
    0xf1, 0x31, 0xe9, 0x28, 0x7d, 0xc0, 0x3c, 0x35, 0xa0, 0x6e, 0x3c, 0x55, 0x15, 0xa6, 0xde, 0x67,
];

fn main() -> io::Result<()> {
    unsafe { START_TIME = SystemTime::now() };
    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer)?;

    stage_1(buffer);

    Ok(())
}

fn stage_1(key: String) {
    if &key == "1234567890\n" {
        let parsed_key = key.parse().unwrap();
        stage_1_dead_end_a(parsed_key);
    }
    let parsed_key = key.parse().unwrap();
    if parsed_key == 1987986 {
        stage_2(parsed_key);
    }
}

fn stage_1_dead_end_a(_key: u64) {
    println!("Beware dead ends!");
}

fn stage_2(key: u64) {
    unsafe {
        if debugapi::IsDebuggerPresent() == 1 {
            return;
        }
    }
    if key ^ 5 + 8 == 19876 {
        stage_2_dead_end_a(key);
    } else if key == 987654321 {
        stage_3(key);
    } else {
        stage_2_dead_end_b(key);
    }
}

fn stage_2_dead_end_a(key: u64) {
    if key as i64 <= -56298105698634855 {
        stage_2(key);
    } else {
        unsafe {
            if debugapi::IsDebuggerPresent() == 1 {
                return;
            }
        }
        stage_2_dead_end_b(key);
    }
}

fn stage_2_dead_end_b(key: u64) {
    let key_i64 = key as i64;
    if key_i64 ^ -key_i64 == 0 {
        stage_2_dead_end_c(key);
    } else {
        stage_2_dead_end_a(key);
    }
    stage_3(key);
}

fn stage_2_dead_end_c(key: u64) {
    stage_2_dead_end_a(key);
    stage_1_dead_end_a(key);
    stage_3(key);
}

fn stage_3(key: u64) {
    let lib = libloading::Library::new("ntdll").unwrap();
    let mut debugger_present: DWORD = 0;
    let debugger_present_ptr = &mut debugger_present as *mut u32;
    let status: NTSTATUS;
    unsafe {
        let nt_query_information_process: libloading::Symbol<
            unsafe extern "C" fn(HANDLE, u32, PDWORD, ULONG, PULONG) -> NTSTATUS,
        > = lib.get(b"NtQueryInformationProcess").unwrap();

        status = nt_query_information_process(
            processthreadsapi::GetCurrentProcess(),
            PROCESS_DEBUG_PORT,
            debugger_present_ptr,
            size_of::<DWORD>() as ULONG,
            NULL as *mut u32,
        );
    }
    if status == 0 && debugger_present != 0 {
        stage_4_final(key);
        return;
    }
    stage_3_dead_end(key);
}

fn stage_3_dead_end(_key: u64) {
    let text = decrypt(&RED_HERRING_CIPHER_TEXT, &RED_HERRING_KEY, &RED_HERRING_IV).unwrap();
    println!("{}", String::from_utf8_lossy(&text));
}

fn stage_4_final(_key: u64) {
    let text = decrypt(&CIPHER_TEXT_HEX, &ENCRYPTION_KEY, &ENCRYPTION_IV).unwrap();
    println!("{}", String::from_utf8_lossy(&text));
}

fn decrypt(
    encrypted_data: &[u8],
    key: &[u8],
    iv: &[u8],
) -> Result<Vec<u8>, symmetriccipher::SymmetricCipherError> {
    let elapsed = unsafe { START_TIME }.elapsed().unwrap();
    let max_difference = Duration::from_secs(15);

    let mut key = key;
    if elapsed > max_difference {
        key = &RED_HERRING_KEY;
    }

    let mut decryptor =
        aes::cbc_decryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);

    let mut final_result = Vec::new();
    let mut read_buffer = buffer::RefReadBuffer::new(encrypted_data);
    let mut out_buffer = [0; 4096];
    let mut write_buffer = buffer::RefWriteBuffer::new(&mut out_buffer);

    loop {
        let result = decryptor
            .decrypt(&mut read_buffer, &mut write_buffer, true)
            .unwrap();

        final_result.extend(
            write_buffer
                .take_read_buffer()
                .take_remaining()
                .iter()
                .map(|&i| i),
        );

        if let BufferResult::BufferUnderflow = result {
            break;
        }
    }

    Ok(final_result)
}
